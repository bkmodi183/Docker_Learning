=====================================================
Multi-stage Docker Builds and Distroless Images Notes
=====================================================

------------------------------------------------------------------------------------------------------------------------------
1. What are Multi-stage Docker Builds:

A multi-stage Docker build is a way to build smaller, cleaner, and more secure Docker images.  
It lets you use multiple FROM statements in a single Dockerfile ‚Äî where each stage can 
have its own base image.

The main idea:
- Use one stage for building or compiling code.
- Use another stage (final image) for running the application.

This avoids copying unnecessary build tools, dependencies, or files into the final image due to which
final images becomes light weight and more secure.

Multi-stage builds separate the build environment from the runtime environment, ensuring that the final image 
contains only the necessary runtime files and dependencies, reducing image size and improving security.

------------------------------------------------------------------------------------------------------------------------------
2. Why We Need Multi-stage Builds:

Without multi-stage builds, your final Docker image includes everything ‚Äî compilers, dependencies, temp files, etc.  
That makes it:
- Larger in size üêò  
- Slower to download or deploy üê¢  
- Less secure üîí  

Multi-stage builds solve this by keeping only what‚Äôs needed to run the app.

Example:

It‚Äôs like cooking ‚Äî you don‚Äôt serve the cutting board and dirty utensils to the customer, only the finished dish.

------------------------------------------------------------------------------------------------------------------------------
3. Example: Multi-stage Dockerfile

Example 1: Node.js

Stage 1: Build the app

FROM node:18 AS builder
WORKDIR /app
COPY package*.json ./
RUN npm install
COPY . .
RUN npm run build

Stage 2: Run the app

FROM node:18-alpine
WORKDIR /app
COPY --from=builder /app/dist ./dist
CMD ["node", "dist/server.js"]

In this multi-stage Dockerfile, Stage 1 (builder) is used to build and compile the application. 
It installs all required dependencies and runs the build process to generate the production-ready artifacts.

Stage 2 is used to run the application. Only the compiled or built output from Stage 1 is copied into this stage, 
along with the minimum runtime dependencies required to execute the application. This stage uses a lightweight base 
image (node:18-alpine), which includes a minimal Linux OS and fewer system libraries, resulting in a smaller and 
more secure final image. Build-time tools and unnecessary dependencies are excluded from the final image.

------------------------------------------------------------------------------------------------------------------------------ 

Example 2: Go application

Stage 1: Build binary

FROM golang:1.20 AS builder
WORKDIR /app
COPY . .
RUN go build -o myapp .

Stage 2: Run app

FROM alpine
WORKDIR /app
COPY --from=builder /app/myapp .
CMD ["./myapp"]


In both examples, the final image contains only what is needed to run the app ‚Äî no extra tools or dependencies.

------------------------------------------------------------------------------------------------------------------------------
4. Benefits of Multi-stage Builds:

‚úÖ Smaller image size  
‚úÖ Faster build and deploy time  
‚úÖ Cleaner and more secure image  
‚úÖ Easier to manage builds for production  

------------------------------------------------------------------------------------------------------------------------------
5. What are Distroless Images:

Distroless images are Docker images that contain only your application and its runtime dependencies.
‚Äî no shell, package manager, or extra OS tools.

They are built by Google and available at:
gcr.io/distroless/<language>

Examples:
- `gcr.io/distroless/nodejs`
- `gcr.io/distroless/java`
- `gcr.io/distroless/python3`

They are called ‚Äúdistroless‚Äù because they do not include a Linux distribution layer ‚Äî only what‚Äôs necessary to run your app.

------------------------------------------------------------------------------------------------------------------------------
6. Why Use Distroless Images:

- Security: Fewer tools = smaller attack surface üîê  
- Smaller Size: Lightweight and fast ‚ö°  
- Stability: Fewer system dependencies to break  
- Compliance: Harder for attackers to get shell access  

Example: If a hacker gains access, a distroless container has no shell or package manager, so attacks are much harder.

------------------------------------------------------------------------------------------------------------------------------

7. Example: Using Distroless Image

For a Go app:
Stage 1: Build binary

FROM golang:1.20 AS builder
WORKDIR /app
COPY . .
RUN go build -o myapp .

Stage 2: Use distroless image

FROM gcr.io/distroless/base
WORKDIR /app
COPY --from=builder /app/myapp .
USER nonroot:nonroot
CMD ["./myapp"]


The final image contains only the binary, making it small and secure.

------------------------------------------------------------------------------------------------------------------------------
8. Multi-Stage + Distroless Together:

You can combine multi-stage builds with distroless images for maximum optimization.

Example:
FROM node:18 AS builder
WORKDIR /app
COPY package*.json ./
RUN npm install
COPY . .
RUN npm run build

FROM gcr.io/distroless/nodejs18
WORKDIR /app
COPY --from=builder /app/dist ./dist
CMD ["dist/server.js"]


‚úÖ Benefits:
- Smaller final image  
- No unnecessary tools  
- More secure runtime environment  

------------------------------------------------------------------------------------------------------------------------------
9. Summary:

| Concept               | Description                                                             |
|-----------------------|-------------------------------------------------------------------------|
| **Multi-stage Build** | Use multiple stages in a Dockerfile to keep final image small and clean |
| **Distroless Image**  | Image contains only app + runtime; no shell or OS packages              |
| **Goal**              | Optimize image size, security, and performance                          |
| **Best Practice**     | Combine multi-stage builds with distroless images for production        |

------------------------------------------------------------------------------------------------------------------------------
10. Analogy:

Multi-stage builds are like preparing a dish in multiple steps ‚Äî only the final plated meal is served.  
Distroless images are like serving the meal on a clean plate without any extra kitchen tools ‚Äî nothing extra, just what‚Äôs needed to enjoy it.

------------------------------------------------------------------------------------------------------------------------------
